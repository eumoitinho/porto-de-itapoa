import { isTextBlock, isSpan } from "@portabletext/schema";
import isEqual from "lodash/isEqual.js";
import uniq from "lodash/uniq.js";
const objectToString = Object.prototype.toString;
function resolveJsType(val) {
  switch (objectToString.call(val)) {
    case "[object Function]":
      return "function";
    case "[object Date]":
      return "date";
    case "[object RegExp]":
      return "regexp";
    case "[object Arguments]":
      return "arguments";
    case "[object Array]":
      return "array";
    case "[object String]":
      return "string";
  }
  return val === null ? "null" : val === void 0 ? "undefined" : val && typeof val == "object" && "nodeType" in val && val.nodeType === 1 ? "element" : val === Object(val) ? "object" : typeof val;
}
function isArbitraryTypedObject(object) {
  return isRecord(object) && typeof object._type == "string";
}
function isRecord(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function flattenNestedBlocks(context, blocks) {
  return blocks.flatMap((block) => {
    if (isBlockContainer(block))
      return flattenNestedBlocks(context, [block.block]);
    if (isTextBlock(context, block)) {
      const hasBlockObjects = block.children.some((child) => context.schema.blockObjects.some(
        (blockObject) => blockObject.name === child._type
      )), hasBlocks = block.children.some(
        (child) => child._type === "__block" || child._type === "block"
      );
      if (hasBlockObjects || hasBlocks) {
        const splitChildren = getSplitChildren(context, block);
        return splitChildren.length === 1 && splitChildren[0].type === "children" && isEqual(splitChildren[0].children, block.children) ? [block] : splitChildren.flatMap((slice) => slice.type === "block object" ? [slice.block] : slice.type === "block" ? flattenNestedBlocks(context, [
          slice.block
        ]) : slice.children.length > 0 ? slice.children.every(
          (child) => isSpan(context, child) && child.text.trim() === ""
        ) ? [] : flattenNestedBlocks(context, [
          {
            ...block,
            children: slice.children
          }
        ]) : []);
      }
      return [block];
    }
    return [block];
  });
}
function isBlockContainer(block) {
  return block._type === "__block" && isArbitraryTypedObject(block.block);
}
function getSplitChildren(context, block) {
  return block.children.reduce(
    (slices, child) => {
      const knownInlineObject = context.schema.inlineObjects.some(
        (inlineObject) => inlineObject.name === child._type
      ), knownBlockObject = context.schema.blockObjects.some(
        (blockObject) => blockObject.name === child._type
      ), lastSlice = slices.pop();
      return !isSpan(context, child) && !knownInlineObject && knownBlockObject ? [
        ...slices,
        ...lastSlice ? [lastSlice] : [],
        { type: "block object", block: child }
      ] : child._type === "__block" ? [
        ...slices,
        ...lastSlice ? [lastSlice] : [],
        {
          type: "block object",
          block: child.block
        }
      ] : child._type === "block" ? [
        ...slices,
        ...lastSlice ? [lastSlice] : [],
        { type: "block", block: child }
      ] : lastSlice && lastSlice.type === "children" ? [
        ...slices,
        {
          type: "children",
          children: [...lastSlice.children, child]
        }
      ] : [
        ...slices,
        ...lastSlice ? [lastSlice] : [],
        { type: "children", children: [child] }
      ];
    },
    []
  );
}
const PRESERVE_WHITESPACE_TAGS = ["pre", "textarea", "code"], BLOCK_DEFAULT_STYLE = "normal", DEFAULT_BLOCK = Object.freeze({
  _type: "block",
  markDefs: [],
  style: BLOCK_DEFAULT_STYLE
}), DEFAULT_SPAN = Object.freeze({
  _type: "span",
  marks: []
}), HTML_BLOCK_TAGS = {
  p: DEFAULT_BLOCK,
  blockquote: { ...DEFAULT_BLOCK, style: "blockquote" }
}, HTML_SPAN_TAGS = {
  span: { object: "text" }
}, HTML_LIST_CONTAINER_TAGS = {
  ol: { object: null },
  ul: { object: null }
}, HTML_HEADER_TAGS = {
  h1: { ...DEFAULT_BLOCK, style: "h1" },
  h2: { ...DEFAULT_BLOCK, style: "h2" },
  h3: { ...DEFAULT_BLOCK, style: "h3" },
  h4: { ...DEFAULT_BLOCK, style: "h4" },
  h5: { ...DEFAULT_BLOCK, style: "h5" },
  h6: { ...DEFAULT_BLOCK, style: "h6" }
}, HTML_MISC_TAGS = {
  br: { ...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE }
}, HTML_DECORATOR_TAGS = {
  b: "strong",
  strong: "strong",
  i: "em",
  em: "em",
  u: "underline",
  s: "strike-through",
  strike: "strike-through",
  del: "strike-through",
  code: "code",
  sup: "sup",
  sub: "sub",
  ins: "ins",
  mark: "mark",
  small: "small"
}, HTML_LIST_ITEM_TAGS = {
  li: {
    ...DEFAULT_BLOCK,
    style: BLOCK_DEFAULT_STYLE,
    level: 1,
    listItem: "bullet"
  }
}, ELEMENT_MAP = {
  ...HTML_BLOCK_TAGS,
  ...HTML_SPAN_TAGS,
  ...HTML_LIST_CONTAINER_TAGS,
  ...HTML_LIST_ITEM_TAGS,
  ...HTML_HEADER_TAGS,
  ...HTML_MISC_TAGS
};
uniq(
  Object.values(ELEMENT_MAP).filter((tag) => "style" in tag).map((tag) => tag.style)
);
uniq(
  Object.values(HTML_DECORATOR_TAGS)
);
function tagName(el) {
  if (el && "tagName" in el)
    return el.tagName.toLowerCase();
}
function defaultParseHtml() {
  if (resolveJsType(DOMParser) === "undefined")
    throw new Error(
      "The native `DOMParser` global which the `Html` deserializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead."
    );
  return (html) => new DOMParser().parseFromString(html, "text/html");
}
function nextSpan(block, index) {
  const next = block.children[index + 1];
  return next && next._type === "span" ? next : null;
}
function prevSpan(block, index) {
  const prev = block.children[index - 1];
  return prev && prev._type === "span" ? prev : null;
}
function isWhiteSpaceChar(text) {
  return ["\xA0", " "].includes(text);
}
function trimWhitespace(schema, blocks) {
  return blocks.forEach((block) => {
    isTextBlock({ schema }, block) && block.children.forEach((child, index) => {
      if (!isMinimalSpan(child))
        return;
      const nextChild = nextSpan(block, index), prevChild = prevSpan(block, index);
      index === 0 && (child.text = child.text.replace(/^[^\S\n]+/g, "")), index === block.children.length - 1 && (child.text = child.text.replace(/[^\S\n]+$/g, "")), /\s/.test(child.text.slice(Math.max(0, child.text.length - 1))) && nextChild && isMinimalSpan(nextChild) && /\s/.test(nextChild.text.slice(0, 1)) && (child.text = child.text.replace(/[^\S\n]+$/g, "")), /\s/.test(child.text.slice(0, 1)) && prevChild && isMinimalSpan(prevChild) && /\s/.test(prevChild.text.slice(Math.max(0, prevChild.text.length - 1))) && (child.text = child.text.replace(/^[^\S\n]+/g, "")), child.text || block.children.splice(index, 1), prevChild && isEqual(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text) ? (prevChild.text += " ", block.children.splice(index, 1)) : nextChild && isEqual(nextChild.marks, child.marks) && isWhiteSpaceChar(child.text) && (nextChild.text = ` ${nextChild.text}`, block.children.splice(index, 1));
    });
  }), blocks;
}
function ensureRootIsBlocks(schema, objects) {
  return objects.reduce((blocks, node, i, original) => {
    if (node._type === "block")
      return blocks.push(node), blocks;
    if (node._type === "__block")
      return blocks.push(node.block), blocks;
    const lastBlock = blocks[blocks.length - 1];
    if (i > 0 && !isTextBlock({ schema }, original[i - 1]) && isTextBlock({ schema }, lastBlock))
      return lastBlock.children.push(node), blocks;
    const block = {
      ...DEFAULT_BLOCK,
      children: [node]
    };
    return blocks.push(block), blocks;
  }, []);
}
function isNodeList(node) {
  return Object.prototype.toString.call(node) === "[object NodeList]";
}
function isMinimalSpan(node) {
  return node._type === "span";
}
function isMinimalBlock(node) {
  return node._type === "block";
}
function isPlaceholderDecorator(node) {
  return node._type === "__decorator";
}
function isPlaceholderAnnotation(node) {
  return node._type === "__annotation";
}
function isElement(node) {
  return node.nodeType === 1;
}
function normalizeWhitespace(rootNode) {
  let emptyBlockCount = 0, lastParent = null;
  const nodesToRemove = [];
  for (let child = rootNode.firstChild; child; child = child.nextSibling) {
    if (!isElement(child)) {
      normalizeWhitespace(child), emptyBlockCount = 0;
      continue;
    }
    const elm = child;
    isWhitespaceBlock(elm) ? (lastParent && elm.parentElement === lastParent ? (emptyBlockCount++, emptyBlockCount > 1 && nodesToRemove.push(elm)) : emptyBlockCount = 1, lastParent = elm.parentElement) : (normalizeWhitespace(child), emptyBlockCount = 0);
  }
  nodesToRemove.forEach((node) => {
    node.parentElement?.removeChild(node);
  });
}
function removeAllWhitespace(rootNode) {
  const nodesToRemove = [];
  function collectNodesToRemove(currentNode) {
    if (isElement(currentNode)) {
      const elm = currentNode;
      if (tagName(elm) === "br" && (tagName(elm.nextElementSibling) === "p" || tagName(elm.previousElementSibling) === "p")) {
        nodesToRemove.push(elm);
        return;
      }
      if ((tagName(elm) === "p" || tagName(elm) === "br") && elm?.firstChild?.textContent?.trim() === "") {
        nodesToRemove.push(elm);
        return;
      }
      for (let child = elm.firstChild; child; child = child.nextSibling)
        collectNodesToRemove(child);
    }
  }
  collectNodesToRemove(rootNode), nodesToRemove.forEach((node) => {
    node.parentElement?.removeChild(node);
  });
}
function isWhitespaceBlock(elm) {
  return ["p", "br"].includes(tagName(elm) || "") && !elm.textContent?.trim();
}
export {
  BLOCK_DEFAULT_STYLE,
  DEFAULT_BLOCK,
  DEFAULT_SPAN,
  HTML_BLOCK_TAGS,
  HTML_DECORATOR_TAGS,
  HTML_HEADER_TAGS,
  HTML_LIST_CONTAINER_TAGS,
  HTML_LIST_ITEM_TAGS,
  HTML_SPAN_TAGS,
  PRESERVE_WHITESPACE_TAGS,
  defaultParseHtml,
  ensureRootIsBlocks,
  flattenNestedBlocks,
  isElement,
  isMinimalBlock,
  isMinimalSpan,
  isNodeList,
  isPlaceholderAnnotation,
  isPlaceholderDecorator,
  normalizeWhitespace,
  removeAllWhitespace,
  resolveJsType,
  tagName,
  trimWhitespace
};
//# sourceMappingURL=helpers.js.map
